{"ast":null,"code":"import _objectSpread from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/hergeirs/Setri/ForritaVerkfr\\xF8\\xF0i/Pixelbrain_tetris/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport React, { Component } from \"react\";\nimport Vector from \"./../Vector/Vector\";\nimport PropTypes from \"prop-types\";\n\nvar GameComponent =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(GameComponent, _Component);\n\n  function GameComponent(props) {\n    var _this;\n\n    _classCallCheck(this, GameComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GameComponent).call(this, props));\n    _this._isChanged = false;\n\n    _this.addRigidBody = function (component) {\n      _this.add(component);\n\n      if (!_this.rigidBody) {\n        _this.rigidBody = component;\n      } else throw new Error(\"more than one rigidBody not supported\");\n    };\n\n    _this.add = function (component) {\n      return _this.components.push(component);\n    };\n\n    _this.addCollisionZone = function (component) {\n      _this.add(component);\n\n      _this.collisionZones.push(component);\n    };\n\n    _this.remove = function (component) {\n      _this.components.filterInPlace(function (component2) {\n        return component2 !== component;\n      });\n\n      _this.collisionZones.filterInPlace(function (component2) {\n        return component2 !== component;\n      });\n    };\n\n    _this.update = function () {\n      if (!_this.mounted) return;\n\n      _this.setState({});\n\n      _this.components.forEach(function (component) {\n        return component.update();\n      });\n    };\n\n    _this.render = function () {\n      return _this.children.map(function (child, idx) {\n        return React.cloneElement(child, _objectSpread({}, _this.props, {\n          name: null\n        }, child.props, {\n          world: _this.props.world,\n          parent: _assertThisInitialized(_assertThisInitialized(_this)),\n          key: idx,\n          position: _this.rigidBody ? _this.rigidBody.position : _this.props.position\n        }));\n      });\n    };\n\n    _this.shouldComponentUpdate = function () {\n      return false;\n    };\n\n    _this.components = [];\n    _this._position = _this.props.position;\n    _this.components = [];\n    _this.rigidBody = null;\n    _this.collisionZones = [];\n    _this.name = _this.props.name;\n    return _this;\n  }\n\n  _createClass(GameComponent, [{\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this2 = this;\n\n      this.children = this.children ? this.children : this.props.children ? this.props.children : [];\n      this.children = this.children.map(function (child, idx) {\n        return React.cloneElement(child, _objectSpread({}, _this2.props, {\n          name: null\n        }, child.props, {\n          world: _this2.props.world,\n          parent: _this2,\n          key: idx,\n          position: _this2.rigidBody ? _this2.rigidBody.position : _this2.props.position\n        }));\n      });\n      this.props.world.registerComponent(this);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.mounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.mounted = false; // this.props.world.unregisterComponent(this);\n      // this.components = [];\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      if (this.rigidBody) return this.rigidBody.position;\n      return this._position;\n    },\n    set: function set(position) {\n      this._isChanged = true;\n      if (this.rigidBody) this.rigidBody.position = position;\n      this._position = position;\n    }\n  }]);\n\n  return GameComponent;\n}(Component);\n\nexport { GameComponent as default };\nGameComponent.defaultProps = {\n  position: new Vector()\n};\nGameComponent.propTypes = {\n  position: PropTypes.instanceOf(Vector).isRequired,\n  name: PropTypes.string.isRequired\n}; // export default WithWorld(GameComponent);","map":{"version":3,"sources":["/home/hergeirs/Setri/ForritaVerkfrøði/Pixelbrain_tetris/src/GameObject/GameComponent.js"],"names":["React","Component","Vector","PropTypes","GameComponent","props","_isChanged","addRigidBody","component","add","rigidBody","Error","components","push","addCollisionZone","collisionZones","remove","filterInPlace","component2","update","mounted","setState","forEach","render","children","map","child","idx","cloneElement","name","world","parent","key","position","shouldComponentUpdate","_position","registerComponent","defaultProps","propTypes","instanceOf","isRequired","string"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport Vector from \"./../Vector/Vector\";\nimport PropTypes from \"prop-types\";\n\nexport default class GameComponent extends Component {\n  constructor(props) {\n    super(props);\n    this._position = this.props.position;\n    this.components = [];\n    this.rigidBody = null;\n    this.collisionZones = [];\n    this.name = this.props.name;\n  }\n  _isChanged = false;\n\n  addRigidBody = component => {\n    this.add(component);\n    if (!this.rigidBody) {\n      this.rigidBody = component;\n    } else throw new Error(\"more than one rigidBody not supported\");\n  };\n\n  add = component => this.components.push(component);\n  addCollisionZone = component => {\n    this.add(component);\n    this.collisionZones.push(component);\n  };\n\n  remove = component => {\n    this.components.filterInPlace(component2 => component2 !== component);\n    this.collisionZones.filterInPlace(component2 => component2 !== component);\n  };\n\n  get position() {\n    if (this.rigidBody) return this.rigidBody.position;\n    return this._position;\n  }\n  set position(position) {\n    this._isChanged = true;\n    if (this.rigidBody) this.rigidBody.position = position;\n    this._position = position;\n  }\n\n  update = () => {\n    if (!this.mounted) return;\n    this.setState({});\n    this.components.forEach(component => component.update());\n  };\n\n  // shouldComponentUpdate() {\n  //   return this._isChanged;\n  // }\n\n  render = () =>\n    this.children.map((child, idx) =>\n      React.cloneElement(child, {\n        ...this.props,\n        name: null,\n        ...child.props,\n\n        world: this.props.world,\n        parent: this,\n        key: idx,\n        position: this.rigidBody ? this.rigidBody.position : this.props.position\n      })\n    );\n\n  shouldComponentUpdate = () => false;\n\n  componentWillMount() {\n    this.children = this.children\n      ? this.children\n      : this.props.children\n      ? this.props.children\n      : [];\n    this.children = this.children.map((child, idx) =>\n      React.cloneElement(child, {\n        ...this.props,\n        name: null,\n        ...child.props,\n\n        world: this.props.world,\n        parent: this,\n        key: idx,\n        position: this.rigidBody ? this.rigidBody.position : this.props.position\n      })\n    );\n    this.props.world.registerComponent(this);\n  }\n  componentDidMount() {\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n    // this.props.world.unregisterComponent(this);\n    // this.components = [];\n  }\n  components = [];\n}\n\nGameComponent.defaultProps = {\n  position: new Vector()\n};\n\nGameComponent.propTypes = {\n  position: PropTypes.instanceOf(Vector).isRequired,\n  name: PropTypes.string.isRequired\n};\n\n// export default WithWorld(GameComponent);\n"]},"metadata":{},"sourceType":"module"}